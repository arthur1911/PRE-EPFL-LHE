# -*- coding: utf-8 -*-
"""
Created on Tue Jul 25 11:12:01 2023

@author: EPFL-LHE
"""
# Librairies
from os.path import join
import numpy as np
from PIL import Image
import os
import cv2
from juliacall import Main as jl
import pandas as pd


def pngToGslib(imagePath):
    '''
    

    Parameters
    ----------
    imagePath : string
        Creates a .gslib file based on the image in argument. It saves the file in the same folder as the image

    Returns
    -------
    None.

    '''
    # Read the image and convert it in gray level
    img = Image.open(imagePath).convert('L')

    # Convert the image into an array
    data = np.array(img)

    # Normalize the values
    data = data / 255.0

    # Create a dataframe for the values
    df = pd.DataFrame(data.flatten(), columns=['Z'])
    
    root, ext = os.path.splitext(imagePath)
    gslibPath = root + ".gslib"

    # Write the gslib file
    with open(gslibPath, 'w') as f:
        f.write("# This file was generated by la Ch'team\n")
        f.write(f"{data.shape[1]} {data.shape[0]}\n")
        f.write("0.000000 0.000000\n")
        f.write("1.000000 1.000000\n")
        f.write("Z\n")

    # Save the gslib file
    df.to_csv(gslibPath, sep=' ', index=False, mode='a', header=False)

def imageQuilting(TIname, TIsize, blur, overlap, tilesize):
    '''
    

    Parameters
    ----------
    TIname : string
        Name of the training image that MUST BE in the folder written in the geostatsimages.jl
    TIsize : array 
        Size of the training image.
    blur : odd int
        Size of the kernel of the Gaussian blur.
    overlap : couple
        Size of the overlap as a fraction of the tilesize.
    tilesize : couple
        Size of the tile in pixels.

    Returns
    -------
    output : array
        Generated image based on the programm from Hoffimann 2017 in Julia

    '''
    # Importing all the usefull modules
    jl.seval('using CUDA')
    jl.seval("using GeoStats")
    jl.seval("using GeoStatsPlots")
    jl.seval("using ImageQuilting")
    jl.seval("using GeoStatsImages")
    jl.seval("using Plots")
    jl.seval("using ImageFiltering")
    jl.seval("using ImageView")
    
    # Sending the argument in julia
    jl.TIname = TIname
    jl.blur = blur
    jl.overlap = overlap
    jl.tilesize = tilesize
    
    # Copying the main code of Hoffimann 
    jl.seval('trainimg = geostatsimage(TIname)')
    jl.seval('function forward(data); img = asarray(data, :Z); krn = KernelFactors.IIRGaussian([blur,blur]); fwd = imfilter(img, krn); georef((fwd=fwd,), domain(data));  end')
    jl.seval('dataTI = forward(trainimg)')
    jl.seval('problem = SimulationProblem(domain(trainimg), :Z => Float64, 1)')
    jl.seval('solver = IQ(:Z => (trainimg = trainimg, overlap = overlap, tilesize = tilesize, soft = (dataTI,dataTI), tol = 0.01, path = :raster))')
    jl.seval('ensemble = solve(problem, solver)')
    
    # Exporting the result in Python and reshape it
    m = jl.seval('ensemble.reals[1][1]')
    a = np.array(m)
    output = a.reshape(TIsize)
    
    # Free the GPU memory (if not, memory full)
    jl.seval('GC.gc()')
    jl.seval('CUDA.reclaim()')
    return output

def consecutiveMHD(folderPath):
    '''
    

    Parameters
    ----------
    folderPath : string
        Path of the folder which contains the time serie.

    Returns
    -------
    MHD : list
        list of the MHD between two consecutive images.

    '''
    # Get the number of images
    allFiles = os.listdir(folderPath)
    images = [file for file in allFiles]
    N = len(images)
    
    # Initialization of the list
    MHD = [0 for i in range(N-1)]
    
    jl.seval('using Images')
    jl.seval('using ImageDistances')
    jl.seval('using ImageMagick')
    jl.seval('using Distances')
    
    jl.seval('function edge(img, threshold=.45); grads = imgradients(img, KernelFactors.ando3); mag = hypot.(grads...); mag .> threshold; end')

    for i in range(N-1):
        nom_image1 = join(folderPath, images[i])
        image1 = cv2.imread(nom_image1, cv2.IMREAD_GRAYSCALE)
        _, image1 = cv2.threshold(image1, 128, 1, cv2.THRESH_BINARY)
        jl.img1 = image1
        edge1 = jl.seval('edge(img1)')
        edge1 = np.array(edge1)
        edge1 = edge1.reshape(np.shape(image1))
        nom_image2 = join(folderPath, images[i+1])
        image2 = cv2.imread(nom_image2, cv2.IMREAD_GRAYSCALE)
        _, image2 = cv2.threshold(image2, 128, 1, cv2.THRESH_BINARY)
        jl.img2 = image2
        edge2 = jl.seval('edge(img2)')
        edge2 = np.array(edge2)
        edge2 = edge2.reshape(np.shape(image1))
        jl.image1 = edge1
        jl.image2 = edge2
        MHD[i] = jl.seval('ImageDistances.modified_hausdorff(image1, image2)')
    return MHD